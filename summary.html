<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Arvo:ital@1&display=swap" rel="stylesheet">
<link rel = "stylesheet" href = "styles.css">
    <title>Sleep Analyser</title>
   
  </head>
<body> 
<nav class ="navbar">
<ul>

  <li class = "brand"><i class = "fa fa-heartbeat"></i></li>
<li class = "active"><a href = "index.html">APP</a></li>
<li><a href = "project.html">Guide</a></li>
</ul>
</nav>
<div class="row">

    <div class = "section" id ="secion1">
    <span class = " span1 sectiont">Weekly Report</span>
  <p id ="text">
  <div id ="centerbutton">

  <button id = "button1" type = "button">Get Sleep Analysis</button>
  
</div>
<div id = "fill">
    <ul>
    <li>Total Hours of Sleep <span class ="span2" id ="sleep"></span></li>
    <li>Total Hours of Recording <span class ="span2" id ="record"></span></li>
    <li>Total Hours of DEEP Sleep <span class ="span2" id = "dsleep"></span></li>
    <li>Total Hours of REM Sleep <span class ="span2" id = "rsleep"></span></li>
    <li>Total Hours of LIGHT Sleep <span class ="span2" id = "lsleep"></span></li>
    <li>Total Hours of Awakeness <span class ="span2" id = "asleep"></span></li>
    <li>Avg Hours of Sleep per day <span class ="span2" id ="avgsleep"></span></li>
    <li>Sleep index<span class ="span2" id ="sleepindex"></span></li>

</ul>
  </div>
  </p>

 
</div>

 
 
 
 
<script src='https://cdn.plot.ly/plotly-2.4.2.min.js'></script> 
<script type = "module">
var datelist = [];
var start_time;
var colour = "black";


// Import the functions you need from the SDKs you need
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.1.3/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.1.3/firebase-analytics.js";
  import{getDatabase, ref, set, child, update, remove,get}
 from  "https://www.gstatic.com/firebasejs/9.1.3/firebase-database.js";
  // TODO: Add SDKs for Firebase products that you want to use
  // https://firebase.google.com/docs/web/setup#available-libraries

  // Your web app's Firebase configuration
  // For Firebase JS SDK v7.20.0 and later, measurementId is optional
  const firebaseConfig = {
  apiKey: "AIzaSyBgIWydOijimi0Hio9DLn692f-K1Ri_jlY",
  authDomain: "sleepanalyzer2-b9951.firebaseapp.com",
  databaseURL: "https://sleepanalyzer2-b9951-default-rtdb.firebaseio.com",
  projectId: "sleepanalyzer2-b9951",
  storageBucket: "sleepanalyzer2-b9951.appspot.com",
  messagingSenderId: "22825152423",
  appId: "1:22825152423:web:2b0c5dfa40a94a44d65082",
  measurementId: "G-DE1W2KHVN3"
};

var time = [];
var datelist = [];
  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const db = getDatabase();
var arraylist = ["Mon","Tue","Wed","Th","Fri","Sat","Sun"];


const dbref = ref(db);

var sumbtn = document.getElementById('button1');
sumbtn.onclick = getData;
var sumdataset =[];
var sumdataset2 = "";
var time3 = [];
var sumdataset3 = [];
function getData()
{  
  sumdataset2 = "";
  time3 = "";
  sumdataset3 = [];
  
 for (var i = 0;i<7;i++)
 {
  var url =`data${i}`;
  const dbref = ref(db);
  get(child(dbref,url)).then(snapshot=>{
  var movements = snapshot.val();
  
 sumdataset2 = sumdataset2 + movements;
 });
 }
 setTimeout( function(){

 var space = document.getElementById('fill');
 var total_hours = sumdataset2.length/3600;
var sumdataset3 = sumdataset2.split("");
var total_sleep = 0;
for(var i = 0;i<sumdataset2.length;i++)
{
total_sleep = total_sleep +1;
}
total_sleep = total_sleep/3600;
var total_awake = total_hours - total_sleep;
var avgsleepperday = total_sleep/7;
let vectors1 = new Array();
var time3 = [];

for(var i =0;i<sumdataset3.length;i++)
{
  time3.push(i);
}
for (let i = 0 ; i < sumdataset2.length ; i++) {
  vectors1[i] = [sumdataset3[i],time3[i]];
}
var res = kmeans(vectors1,4);
var sleepindex = [];
for(var i =0;i<4;i++)
{
sleepindex.push(calcsleepindex(res.clusters[i].points));
}
var rem;
var deep;
var light;
var awake;
var newsleepindex = sleepindex;
newsleepindex.sort();
for(var i =0;i<4;i++)
{
for(var j = 0;j<4;j++)
{
  if(newsleepindex[i]==sleepindex[j])
  {
     var pos = j;
  }
}
if(pos==3)
{
  deep = res.clusters[i].points;
}
else if(pos==2){
  light = res.clusters[i].points;
}
else if(pos==1)
{
  rem= res.clusters[i].points;
}
else{
  awake = res.clusters[i].points;
}
}
var n_rem = rem.length/3600;

var n_deep_sleep = deep.length/3600;
var n_light = light.length/3600;
var avgsleep = total_sleep/7;
var ml = 0;
for(var i = 0;i<sumdataset3.length;i++)
{
    if(sumdataset3[i] =='1'){
        ml = ml +1;
    }

}
console.log(sumdataset2.length)
document.getElementById('sleep').innerHTML = total_sleep.toFixed(2);
document.getElementById('record').innerHTML = total_hours.toFixed(2);
document.getElementById('lsleep').innerHTML = n_light.toFixed(2);
document.getElementById('rsleep').innerHTML = n_rem.toFixed(2);
document.getElementById('dsleep').innerHTML = n_deep_sleep.toFixed(2);
document.getElementById('asleep').innerHTML = (total_hours-n_rem-n_light-n_deep_sleep).toFixed(2);
document.getElementById('avgsleep').innerHTML = avgsleep.toFixed(2);
document.getElementById('sleepindex').innerHTML = ((sumdataset3.length)/(ml+sumdataset3.length)).toFixed(2);
sumdataset =[];
   sumdataset2 = "";
   time3 = [];
sumdataset3 = [];
vectors1= [];
},2000);
}




//Clustering Algorithm start
const MAX_ITERATIONS = 50;

function randomBetween(min, max) {
  return Math.floor(
    Math.random() * (max - min) + min
  );
}

function calcMeanCentroid(dataSet, start, end) {
  const features = dataSet[0].length;
  const n = end - start;
  let mean = [];
  for (let i = 0; i < features; i++) {
    mean.push(0);
  }
  for (let i = start; i < end; i++) {
    for (let j = 0; j < features; j++) {
      mean[j] = mean[j] + dataSet[i][j] / n;
    }
  }
  return mean;
}

function getRandomCentroidsNaiveSharding(dataset, k) {
  // implementation of a variation of naive sharding centroid initialization method
  // (not using sums or sorting, just dividing into k shards and calc mean)
  // https://www.kdnuggets.com/2017/03/naive-sharding-centroid-initialization-method.html
  const numSamples = dataset.length;
  // Divide dataset into k shards:
  const step = Math.floor(numSamples / k);
  const centroids = [];
  for (let i = 0; i < k; i++) {
    const start = step * i;
    let end = step * (i + 1);
    if (i + 1 === k) {
      end = numSamples;
    }
    centroids.push(calcMeanCentroid(dataset, start, end));
  }
  return centroids;
}

function getRandomCentroids(dataset, k) {
  // selects random points as centroids from the dataset
  const numSamples = dataset.length;
  const centroidsIndex = [];
  let index;
  while (centroidsIndex.length < k) {
    index = randomBetween(0, numSamples);
    if (centroidsIndex.indexOf(index) === -1) {
      centroidsIndex.push(index);
    }
  }
  const centroids = [];
  for (let i = 0; i < centroidsIndex.length; i++) {
    const centroid = [...dataset[centroidsIndex[i]]];
    centroids.push(centroid);
  }
  return centroids;
}

function compareCentroids(a, b) {
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

function shouldStop(oldCentroids, centroids, iterations) {
  if (iterations > MAX_ITERATIONS) {
    return true;
  }
  if (!oldCentroids || !oldCentroids.length) {
    return false;
  }
  let sameCount = true;
  for (let i = 0; i < centroids.length; i++) {
    if (!compareCentroids(centroids[i], oldCentroids[i])) {
      sameCount = false;
    }
  }
  return sameCount;
}

// Calculate Squared Euclidean Distance
function getDistanceSQ(a, b) {
  const diffs = [];
  for (let i = 0; i < a.length; i++) {
    diffs.push(a[i] - b[i]);
  }
  return diffs.reduce((r, e) => (r + (e * e)), 0);
}

// Returns a label for each piece of data in the dataset. 
function getLabels(dataSet, centroids) {
  // prep data structure:
  const labels = {};
  for (let c = 0; c < centroids.length; c++) {
    labels[c] = {
      points: [],
      centroid: centroids[c],
    };
  }
  // For each element in the dataset, choose the closest centroid. 
  // Make that centroid the element's label.
  for (let i = 0; i < dataSet.length; i++) {
    const a = dataSet[i];
    let closestCentroid, closestCentroidIndex, prevDistance;
    for (let j = 0; j < centroids.length; j++) {
      let centroid = centroids[j];
      if (j === 0) {
        closestCentroid = centroid;
        closestCentroidIndex = j;
        prevDistance = getDistanceSQ(a, closestCentroid);
      } else {
        // get distance:
        const distance = getDistanceSQ(a, centroid);
        if (distance < prevDistance) {
          prevDistance = distance;
          closestCentroid = centroid;
          closestCentroidIndex = j;
        }
      }
    }
    // add point to centroid labels:
    labels[closestCentroidIndex].points.push(a);
  }
  return labels;
}

function getPointsMean(pointList) {
  const totalPoints = pointList.length;
  const means = [];
  for (let j = 0; j < pointList[0].length; j++) {
    means.push(0);
  }
  for (let i = 0; i < pointList.length; i++) {
    const point = pointList[i];
    for (let j = 0; j < point.length; j++) {
      const val = point[j];
      means[j] = means[j] + val / totalPoints;
    }
  }
  return means;
}

function recalculateCentroids(dataSet, labels, k) {
  // Each centroid is the geometric mean of the points that
  // have that centroid's label. Important: If a centroid is empty (no points have
  // that centroid's label) you should randomly re-initialize it.
  let newCentroid;
  const newCentroidList = [];
  for (const k in labels) {
    const centroidGroup = labels[k];
    if (centroidGroup.points.length > 0) {
      // find mean:
      newCentroid = getPointsMean(centroidGroup.points);
    } else {
      // get new random centroid
      newCentroid = getRandomCentroids(dataSet, 1)[0];
    }
    newCentroidList.push(newCentroid);
  }
  return newCentroidList;
}

function kmeans(dataset, k, useNaiveSharding = true) {
  if (dataset.length && dataset[0].length && dataset.length > k) {
    // Initialize book keeping variables
    let iterations = 0;
    let oldCentroids, labels, centroids;

    // Initialize centroids randomly
    if (useNaiveSharding) {
      centroids = getRandomCentroidsNaiveSharding(dataset, k);
    } else {
      centroids = getRandomCentroids(dataset, k);
    }

    // Run the main k-means algorithm
    while (!shouldStop(oldCentroids, centroids, iterations)) {
      // Save old centroids for convergence test.
      oldCentroids = [...centroids];
      iterations++;

      // Assign labels to each datapoint based on centroids
      labels = getLabels(dataset, centroids);
      centroids = recalculateCentroids(dataset, labels, k);
    }

    const clusters = [];
    for (let i = 0; i < k; i++) {
      clusters.push(labels[i]);
    }
    const results = {
      clusters: clusters,
      centroids: centroids,
      iterations: iterations,
      converged: iterations <= MAX_ITERATIONS,
    };
    return results;
  } else {
    throw new Error('Invalid dataset');
  }
}
//Clustering Algorithm end
function calcsleepindex(data)
{
var sum = 0;
for(var i =0;i<data.length;i++)
{
  sum = sum + parseFloat(data[i]);
}
if(data.length==0)
{
  return 1;
}
return (parseFloat(sum/data.length));
}

</script>
<footer>
    <nav class ="navbar">
      <ul>
      <li class = "active1 toggle" id ="summar"><a href ="summary.html">Overall</a></li>
      <li id = "goback"><a href = "index.html">Go Back</a></li>  
    </ul>
      </nav>
  </footer>

</body>

</html>